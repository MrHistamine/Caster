####################################################################################################
#   Copyright (C) 2013  Darin Woods
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#   Program:    Caster
#   Version:    1.3.2
#   Author:     Darin Woods, Niridia Computer Systems
#   Email:      support@niridia.com
#   Updated:    2014-01-15
#   Summary:    Contains code that allows a user to set properties of an application launcher, and
#               outputs those settings to a complete plugin folder structure containing the
#               necessary code, info, and settings files.
####################################################################################################

import platform
import os
import sys
import shutil
import re
import time

CASTER_VERSION = '1.3.2'
APPLICATION_PREFIX = "/applications/caster"
VG_MAIN_MENU = 'CasterMainMenu'
VG_DIR_NAV = 'CasterDirNav'
THUMBS_PREFIX = 'thumbs-' #'thumbs/'
BUNDLE_SUFFIX = '.bundle'
WIN_PLUGIN_FOLDER = 'Plug-ins\\'
CONTENT_FOLDER = 'Contents'
CODE_FOLDER = 'Code'
RESOURCES_FOLDER = 'Resources'
LICENSE_FILE = 'GNU-GPL_License.txt'
PLIST_INFO_FILE = 'Info.plist'
INIT_PYTH_FILE = '__init__.py'
DEFAULT_PREFS_FILE = 'DefaultPrefs.json'
DEFAULT_ICON_FILE = 'icon-default'
DEFAULT_ART_FILE = 'art-default'

APP_NAME = 'Caster'
ART = 'art-default.png'
ICON = 'icon-default.png'
NONE_TEXT = L('app_none_text')
INITIAL_LOAD = True
LINUX_SYS = False

ROOT_DIRECTORY = "C:/"
PLEX_SERVER_DIR = "\\Plex Media Server"
SETTINGS_DICT = {}
VALID_EXECUTABLES = ['.exe', '.bat', '.app']    # List of valid executables
VALID_IMAGES = ['.png', '.jpg', '.jpeg']   # List of valid image types
VALID_TEXT = ['.txt'] # List of valid text file types

APP_LOC_KEY = 'app_loc_key'
APP_PARAMS_KEY = 'app_cl_params_key'
APP_NAME_KEY = 'app_name_key'
APP_SECT_KEY = 'home_scrn_sect_key'
APP_DESC_KEY = 'AppDescKey'
APP_ICON_KEY = 'app_icon_key'
APP_ART_KEY = 'app_art_key'

#===================================================================================================
#   SECTION:  CODE FOR THE INFO AND INIT FILES
#===================================================================================================
INFO_CODE = """<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
<plist version=\"1.0\">
    <dict>
        <key>CFBundleIdentifier</key>
        <string>com.niridia.{identifier}</string>
        <key>PlexClientPlatformExclusions</key>
        <string>Roku</string>
        <key>PlexClientPlatforms</key>
        <string>*</string>
        <key>PlexFrameworkVersion</key>
        <string>2</string>
        <key>PlexPluginConsoleLogging</key>
        <string>1</string>
        <key>PlexPluginDevMode</key>
        <string>0</string>
    </dict>
</plist>"""

DEFAULT_PREFS = """[
    {{
        "id"        :   "app_cl_params_key",
        "label"     :   "Command Line Parameters:",
        "type"      :   "text",
        "default"   :   "{appParams}"
    }},
    {{
        "id"        :   "app_loc_key",
        "label"     :   "Executable Address:",
        "type"      :   "text",
        "default"   :   "{appExecutable}"
    }}
]"""

INIT_CODE = """####################################################################################################
#   Copyright (C) 2013  Darin Woods, Niridia Computer Systems
#
#   THIS CODE WAS AUTOMATICALLY GENERATED BY THE "CASTER" PLUGIN, VERSION {casterVersion}
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#   Author:     Darin Woods, Niridia Computer Systems
#   Email:      support@niridia.com
#   Created:    {creationDate}
#   Summary:    Contains generated code used to launch a user-defined application.
####################################################################################################

import os, subprocess

APPLICATION_PREFIX = '/{homeSect}/{appName}'
NAME = '{appTitle}'
ART = 'art-default{artFileExt}'
ICON = 'icon-default{iconFileExt}'
DESC = \"""{appDesc}\"""

####################################################################################################
#   This function is initially called by the PMS framework to initialize the plugin.
#       [Takes no arguments]
#
def Start():
    # Initialize the plugin
    Plugin.AddPrefixHandler(APPLICATION_PREFIX, MainMenu, NAME, ICON, ART)
    Plugin.AddViewGroup('CasterList', viewMode = 'List', mediaType = 'items')

    # Setup the thumb associated with the plugin
    DirectoryItem.thumb = R(ICON)
    
####################################################################################################
#   This function builds the main menu.
#       [Takes no arguments]
#
def MainMenu():
    dir = ObjectContainer(view_group = 'CasterList', art = R(ART), title1 = NAME)
    dir.add(DirectoryObject(key = Callback(CastApp), title = '{btnCast}', summary = DESC))
    dir.add(PrefsObject(title = '{btnOptions}', summary = '{optionsDesc}'))
    return dir

####################################################################################################
#   This function launches the application.
#       [Takes no arguments]
#
def CastApp():
    Log.Info('Running Application:  \"' + str(Prefs['{runPath}']) + '\", with the following arguments \"' + ClearNoneString(Prefs['{runArgs}']) + '\"')
    subprocess.Popen([str(Prefs['{runPath}']), ClearNoneString(Prefs['{runArgs}'])])

####################################################################################################
#   Converts a string with a None value, to an empty string.
#       value - the value to convert to an empty string, if it is of None value
#
def ClearNoneString(value):
    if((value is None) or (value is '{noneText}')):
        return ''
    return value"""

#===================================================================================================
#   SECTION:  METHODS / FUNCTIONS
#===================================================================================================

####################################################################################################
#   This function is initially called by the PMS framework to initialize the plugin.
#       [Takes no arguments]
#
def Start():
    # Initialize the plugin
    Plugin.AddPrefixHandler(APPLICATION_PREFIX, MainMenu, APP_NAME, ICON, ART)
    Plugin.AddViewGroup(VG_MAIN_MENU, viewMode = 'InfoList', mediaType = 'items')
    Plugin.AddViewGroup(VG_DIR_NAV, viewMode = 'InfoList', mediaType = 'items')

    # Setup the artwork associated with the plugin
    DirectoryItem.thumb = R(ICON)

####################################################################################################
#   This function builds the main menu.
#       [Optional] initialOpen - indicates whether or not this is being called
#                                from the "Applications" menu
#       returns - the main menu directory's navigation structure
#
def MainMenu():
    dir = ObjectContainer(view_group = VG_MAIN_MENU, art = R(ART), title1 = L('menu_main_title'), replace_parent = True, no_cache = True)
    global LINUX_SYS
    global ROOT_DIRECTORY
    global INITIAL_LOAD

    LINUX_SYS = (platform.system() is 'Linux')
    Log.Debug('Running on platform:  ' + platform.system() + '; is a Linux system? ' + str(LINUX_SYS))

    ROOT_DIRECTORY = os.path.splitdrive(sys.executable)[0] + '/'
    Log.Debug('Root Directory:  ' + ROOT_DIRECTORY)

    if(INITIAL_LOAD is True):
        # Initialize the settings dictionary, each time the main menu is opened from the main interface.
        Log.Debug('Initializing the settings dictionary.')
        ResetSettingsDict()
        INITIAL_LOAD = False
    
    # Add directory object to apply preferences to the generated launcher.
    dir.add(PrefsObject(title = L('prefs_menu_title'),
                        thumb = R(THUMBS_PREFIX + 'option_select.png'),
                        summary = str(L('prefs_menu_desc')).format(appName = Prefs[APP_NAME_KEY], appSection = Prefs[APP_SECT_KEY], appParams = Prefs[APP_PARAMS_KEY])))
    
    # Add directory object for the selecting of the executable to launch.
    dir.add(DirectoryObject(key = Callback(DirectoryNavigator, settingKey = APP_LOC_KEY, fileFilter = VALID_EXECUTABLES),
                            title = L('dir_app_address_title'),
                            thumb = R(THUMBS_PREFIX + 'app_select.png'),
                            summary = str(L('dir_app_address_desc')).format(appAddress = SETTINGS_DICT[APP_LOC_KEY])))
    
    # Add directory object for the selecting of the image file representing the generated launcher's icon.
    dir.add(DirectoryObject(key = Callback(DirectoryNavigator, settingKey = APP_ICON_KEY, fileFilter = VALID_IMAGES),
                            title = L('dir_app_icon_title'),
                            thumb = R(THUMBS_PREFIX + 'icon_select.png'),
                            summary = str(L('dir_app_icon_desc')).format(iconAddress = SETTINGS_DICT[APP_ICON_KEY])))
                            
    # Add directory object for the selecting of the image file representing the generated launcher's artwork.
    dir.add(DirectoryObject(key = Callback(DirectoryNavigator, settingKey = APP_ART_KEY, fileFilter = VALID_IMAGES),
                            title = L('dir_app_art_title'),
                            thumb = R(THUMBS_PREFIX + 'art_select.png'),
                            summary = str(L('dir_app_art_desc')).format(artAddress = SETTINGS_DICT[APP_ART_KEY])))
    
    # Add directory object for the selecting of the file containing the generated launcher's description.
    dir.add(DirectoryObject(key = Callback(DirectoryNavigator, settingKey = APP_DESC_KEY, fileFilter = VALID_TEXT),
                            title = L('dir_app_desc_title'),
                            thumb = R(THUMBS_PREFIX + 'description_select.png'),
                            summary = str(L('dir_app_desc_desc')).format(descAddress = SETTINGS_DICT[APP_DESC_KEY])))
    
    # Add directory object that builds the caster.
    dir.add(DirectoryObject(key = Callback(CreateAppCaster),
                            title = L('btn_create_caster_title'),
                            thumb = R(THUMBS_PREFIX + 'cast.png'),
                            summary = str(L('btn_create_caster_desc')).format(createInSec = Prefs[APP_SECT_KEY])))
    
    Log.Debug('Main menu directory built; returning now.')
    return dir

####################################################################################################
#   This function builds the sub-menus used to display the list of sub-directories and
#   files in the selected parent directory.
#       settingKey - the key to use when saving the selected file to the settings dictionary
#       [Optional] newDirectory - the sub-directory to load
#       [Optional] fileFilter - the list of file extensions to filter against
#       returns - a directory structure containing the sub-files and sub-folders of the selected parent
#
def DirectoryNavigator(settingKey, newDirectory = None, fileFilter = None):
    containerTitle = ROOT_DIRECTORY
    if(newDirectory is not None):
        containerTitle = newDirectory
    
    dir = ObjectContainer(view_group = VG_DIR_NAV, art = R(ART), title1 = containerTitle, no_cache = True)

    # Here, we check the value of the "newDirectory" argument.
    # If it isn't an empty string or a null value, then attempt
    # to retrieve the directory one level up.  If we're all the
    # way back at the "C:" drive, then pass back a null value.
    # This will force the callback to ignore adding the "Back"
    # link, to the list of files and directories.
    if((newDirectory is not "") and (newDirectory is not None)):
        cleanedPath = newDirectory.rstrip('/')
        splitIndex = cleanedPath.rfind('/')
        if(splitIndex < 0):
            cleanedPath = None
        else:
            cleanedPath = cleanedPath[:(splitIndex + 1)]
        Log.Debug('Adding entry allowing navigation back to parent directory; setting key:  ' + settingKey + ', parent directory:  ' + str(cleanedPath))
        dir.add(DirectoryObject(key = Callback(DirectoryNavigator, settingKey = settingKey, newDirectory = cleanedPath, fileFilter = fileFilter),
                                title = L('dir_back_title'),
                                summary = L('dir_back_desc')))
    else:
        newDirectory = ROOT_DIRECTORY
    
    basePath = newDirectory
    subItems = os.listdir(basePath)

    # Sets the reference to the icon image, based on the type of
    # file we're filtering for.
    fileTypeIcon = DEFAULT_ICON_FILE + '.png'
    if(fileFilter == VALID_EXECUTABLES):
        fileTypeIcon = THUMBS_PREFIX + 'executable.png'
    elif(fileFilter == VALID_IMAGES):
        fileTypeIcon = THUMBS_PREFIX + 'image.png'
    elif(fileFilter == VALID_TEXT):
        fileTypeIcon = THUMBS_PREFIX + 'text.png'
    
    # Checks each item within the current directory.  If the item is an
    # executable or batch file, then display it, assigning the "ApplyValue"
    # function as its callback.  This will call the function that stores
    # the address of the executable.  Else-if the item is a directory, then
    # link back to this function; this will generate a new list of
    # selectable items (if the directory is selected).
    for item in subItems:
        if(IsValidFile(basePath + item, fileFilter)):
            Log.Debug('The following file is valid: \"' + basePath + item + '\"; save it if clicked.')
            dir.add(DirectoryObject(key = Callback(ApplyValue, key = settingKey, value = basePath + item),
                                    title = item,
                                    thumb = R(fileTypeIcon)))
        elif(os.path.isdir(basePath + item)):
            Log.Debug('Set up navigation to the following directory:  ' + basePath + item + '/')
            dir.add(DirectoryObject(key = Callback(DirectoryNavigator, settingKey = settingKey, newDirectory = basePath + item + '/', fileFilter = fileFilter),
                                    title = item,
                                    thumb = R(THUMBS_PREFIX + 'folder.png')))

    return dir

####################################################################################################
#   Applies the passed-in value, to the settings dictionary, using the specified key.
#       key - the key of the dictionary entry we're updating
#       value - the value to apply to the specified entry
#       returns - the main menu directory's navigation structure
#
def ApplyValue(key, value):
    Log.Debug('Applying \"' + value + '\", using \"' + key + '\" as its key.')
    if((key is not "") and (value is not "")):
        SETTINGS_DICT[key] = value
        Log.Debug('The settings dictionary has been updated:  ' + key + ',' + SETTINGS_DICT[key] + '.')

    return MainMenu()

####################################################################################################
#   Process the input from the on-screen keyboard.
#       query - the string returned from the keyboard
#       key - the key of the dictionary entry we want to update
#       returns - the main menu directory's navigation structure, from the "ApplyValue" function
#
def InputProcessor(query, key):
    return ApplyValue(key, query)

####################################################################################################
#   Takes a path as a string, and checks it for a valid executable-type extension.
#       checkItem - the string to check
#       returns - a boolean indicating whether or not the path ends with a valid extension
#
def IsValidFile(checkItem, validationList):
    if(validationList is None):
        Log.Debug('A list to validate against, was not passed through.')
        return not True

    if(LINUX_SYS and (validationList == VALID_EXECUTABLES)):
        Log.Debug('Checking that file is executable...')
        return os.access(checkItem, os.X_OK)

    for extension in validationList:
        Log.Debug('Checking \"' + checkItem + '\" against \"' + extension + '\"...')
        if(checkItem.endswith(extension)):
            Log.Debug('\"' + checkItem + '\" has a valid extension.')
            return True
	
    Log.Debug('\"' + checkItem + '\" does not have a valid extension.')
    return not True

####################################################################################################
#   Resets the values in the settings dictionary, to their default values.
#       [Takes no arguments]
#
def ResetSettingsDict():
    Log.Debug('Resetting the values in Caster\'s settings dictionary.')
    SETTINGS_DICT[APP_LOC_KEY] = NONE_TEXT
    SETTINGS_DICT[APP_ICON_KEY] = NONE_TEXT
    SETTINGS_DICT[APP_DESC_KEY] = NONE_TEXT
    SETTINGS_DICT[APP_ART_KEY] = NONE_TEXT

####################################################################################################
#   Converts a string with a None value, to an empty string.
#       value - the value to convert to an empty string, if it is of None value
#
def ClearNoneString(value):
    if((value is None) or (value is NONE_TEXT)):
        return ''
    return value

####################################################################################################
#   Copy the specified source file, to the specified directory, using the specified file name.
#   The original files extension is maintained.
#       srcFilePath - the full path of the source file
#       destDirPath - the full path to the destination directory
#       destFileName - the name to use for the destination file
#
def CopyFile(srcFilePath, destDirPath, destFileName):
    # Copy the given source file to the specified directory, with
    # the specified file name (the extension is maintained).
    if(srcFilePath is not NONE_TEXT):
        sourceDir, sourceExt = os.path.splitext(srcFilePath)
        destFile = os.path.join(destDirPath, destFileName + sourceExt)
        Log.Debug('Copying the source file \"' + srcFilePath + '\", to the following location:  ' + destFile)
        shutil.copy(srcFilePath, destFile)

####################################################################################################
#   Copy the specified source file, to the specified directory, using the specified file name.
#   The original files extension is maintained.
#       [Takes no arguments]
#       returns - a message container indicating success or failure
#
def CreateAppCaster():
    # Create a string representing the location of the plugin folder;
    # make sure that the plug-in folder exists before continuing.  If
    # it does not, display a message to the user.
    pluginFolder = os.getcwd().strip('\\?')
    splitIndex = pluginFolder.rfind(PLEX_SERVER_DIR) + len(PLEX_SERVER_DIR)
    pluginFolder = pluginFolder[:(splitIndex + 1)] + WIN_PLUGIN_FOLDER
    Log.Debug('Looking for the plug-in folder, at the following address:  ' + pluginFolder)
    if(os.path.isdir(pluginFolder) is not True):
        Log.Error('The plug-in folder at:  \"' + pluginFolder + '\", could not be found!')
        return MessageContainer(L('msg_no_folder_title'), str(L('msg_no_folder_body')).format(missingFolder = pluginFolder))

    # Here, we create the plugin's ".bundle", "Contents", "Code", and "Resources"
    # folders (if they don't already exist).  First, we normalize the application
    # name to make sure it's a valid file name.  Next, we build the path to the
    # "Contents" folder, the "Code" folder, and the "Resources" folder.  Finally,
    # we create the code and resource folders (if they don't already exist).  We
    # don't need to explicitly create the "Contents" folder, since it will
    # automatically get created when the code and resource folders are created
    # (if it doesn't exist already).
    normAppName = os.path.normpath(os.path.normcase(APP_NAME + '_' + str(Prefs[APP_NAME_KEY]))).replace(' ', '_')
    contentsPath = os.path.join(pluginFolder, normAppName + BUNDLE_SUFFIX, CONTENT_FOLDER)
    codePath = os.path.join(pluginFolder, normAppName + BUNDLE_SUFFIX, CONTENT_FOLDER, CODE_FOLDER)
    resourcesPath = os.path.join(pluginFolder, normAppName + BUNDLE_SUFFIX, CONTENT_FOLDER, RESOURCES_FOLDER)
    Log.Debug('Creating the following folders:\n    Content:  ' + contentsPath + '\n    Code:  ' + codePath + '\n    Resources:  ' + resourcesPath)
    if(os.path.exists(codePath) is not True):
        os.makedirs(codePath)
    if(os.path.exists(resourcesPath) is not True):
        os.makedirs(resourcesPath)
    
    # Here, we copy the licensing information file from the "Caster" directory,
    # to the new plug-in's main content folder.
    licenseFile = os.path.join(pluginFolder, APP_NAME + BUNDLE_SUFFIX, CONTENT_FOLDER, LICENSE_FILE)
    CopyFile(licenseFile, contentsPath, LICENSE_FILE.replace('.txt', ''))
    
    # Next, we copy the image file representing the new plug-in's icon, from
    # the indicated directory, to the new plug-in's resource folder.
    CopyFile(SETTINGS_DICT[APP_ICON_KEY], resourcesPath, DEFAULT_ICON_FILE)
    
    # We then copy the image file representing the new plug-in's artwork,
    # from the indicated directory, to the new plug-in's resource folder.
    CopyFile(SETTINGS_DICT[APP_ART_KEY], resourcesPath, DEFAULT_ART_FILE)
    
    # Next up, we write the body of text stored in the INFO_CODE variable, to
    # the new "Info.plist" file we're creating.  We replace instances of the
    # specified key, with the normalized name of the new plug-in.
    WriteFile(contentsPath, PLIST_INFO_FILE, INFO_CODE.format(identifier = normAppName))
    
    # Here, we write the body of text stored in the DEFAULT_PREFS, to the new
    # "DefaultPrefs.json" file we're creating.  We replace instances of the
    # specified keys, with the command line arguments to use when calling the
    # application, as well as its full path.
    WriteFile(contentsPath, DEFAULT_PREFS_FILE, DEFAULT_PREFS.format(appParams = ClearNoneString(Prefs[APP_PARAMS_KEY]), appExecutable = SETTINGS_DICT[APP_LOC_KEY]))
    
    # Finally, we call a specific function to create the "__init__.py" file.
    WriteInitFile(codePath, normAppName)
    
    # If everything completed successfully, display a message, indicating success.
    return MessageContainer(L('msg_success_title'), str(L('msg_success_body')).format(menuName = Prefs[APP_SECT_KEY]))
    
####################################################################################################
#   Write the passed-in string to the specified file, at the specified address.
#       destPath - the full path to the directory where the file will be written
#       fullFileName - the full name of the file (including the extension)
#       fileContents - the string to write to the file
#
def WriteFile(destPath, fullFileName, fileContents):
    fileAddress = os.path.join(destPath, fullFileName)
    fd = os.open(fileAddress, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
    outFile = os.fdopen(fd, "w+")
    outFile.write(fileContents)
    outFile.close()
    Log.Debug('The file: \"' + fileAddress + '\", was successfully written to.')

####################################################################################################
#   Write the "__init__.py" file, at the specified address.
#       destPath - the full path to the directory where the file will be written
#       normalizedName - the file system normalized name of the application
#
def WriteInitFile(destPath, normalizedName):
    # Open the text file containing the description of the application, if one's been specified.
    setAppDesc = str(L('gen_launch_default_desc')).format(launchAppName = Prefs[APP_NAME_KEY])
    if(SETTINGS_DICT[APP_DESC_KEY] is not None):
        fd = os.open(SETTINGS_DICT[APP_DESC_KEY], os.O_RDONLY)
        descFile = os.fdopen(fd, 'r')
        lines = descFile.readlines()
        setAppDesc = ''
        setAppDesc = unicode(setAppDesc.join(lines), encoding = 'utf8', errors = 'ignore')
        Log.Debug('Description file loaded:  \n' + setAppDesc)
    
    # Open and/or create the "__init__" file, writing in the code used to run the plugin.
    sourceIconDir, sourceIconExt = os.path.splitext(SETTINGS_DICT[APP_ICON_KEY])
    sourceArtDir, sourceArtExt = os.path.splitext(SETTINGS_DICT[APP_ART_KEY])
    initFile = os.path.join(destPath, INIT_PYTH_FILE)
    fd = os.open(initFile, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
    outFile = os.fdopen(fd, "w+")
    
    outFile.write(INIT_CODE.format(homeSect = Prefs[APP_SECT_KEY].lower(),
                  casterVersion = CASTER_VERSION,
				  creationDate = time.strftime("%Y-%m-%d"),
                  appName = normalizedName,
                  artFileExt = sourceArtExt,
                  iconFileExt = sourceIconExt,
                  appTitle = Prefs[APP_NAME_KEY],
                  appDesc = setAppDesc,
                  btnCast = str(L('gen_launch_title')).format(launchAppName = Prefs[APP_NAME_KEY]),
                  btnOptions = L('gen_options_title'),
                  optionsDesc = str(L('gen_options_desc')).format(launchAppName = Prefs[APP_NAME_KEY]),
                  runArgs = APP_PARAMS_KEY,
                  runPath = APP_LOC_KEY,
                  noneText = L(NONE_TEXT)))
    outFile.close()
    Log.Debug('The file: \"' + initFile + '\", was successfully written to.')